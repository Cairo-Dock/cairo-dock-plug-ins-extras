#!/usr/bin/python

# This is a part of the external Twitter applet for Cairo-Dock
#
# Author: Eduardo Mucelli Rezende Oliveira
# E-mail: edumucelli@gmail.com or eduardom@dcc.ufmg.br
#
# This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.

# This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#  GNU General Public License for more details.

# This applet provides for Cairo-Dock an interface with Twitter

# On the first time, the applet is going to ask your nickname and authorization to connect with Twitter.
# The applet is going to open your browser with the authorization page
# As soon as you authorize it, a PIN number will be shown on the page, copy this number
# Paste this number on the next dialog box will be shown.
# The plugin is going to inform that you are successfully connected.

# To see the received tweets right-click on the icon -> Twitter -> New tweets.
# To see the received direct messages right-click on the icon -> Twitter -> Received direct messages
# To see some user's info right-click on the icon -> Twitter -> Info

import urlparse, os, webbrowser, simplejson, threading, Queue, time, urllib2, simplejson
from oauth import oauth
from http import post, get #, stream
from util import *
from CDApplet import CDApplet, _
# TODO import ConfigParser later conver files to config syntax
# from threading import Thread
# import time

class TwitterOauth:
  def __init__(self):
    self.request_token_url  = 'https://twitter.com/oauth/request_token'
    self.access_token_url   = 'https://twitter.com/oauth/access_token'
    self.authorize_url      = 'http://twitter.com/oauth/authorize'

    consumer_key, consumer_secret = read_consumer_key_and_secret()
    self.consumer = oauth.OAuthConsumer(consumer_key, consumer_secret)
    self.signature_method = oauth.OAuthSignatureMethod_HMAC_SHA1()
    self.request_token = None
    self.access_token = None
    
  def get_authorization_url(self):
    self.request_token = self.get_unauthorized_request_token()
    oauth_request = oauth.OAuthRequest.from_consumer_and_token(self.consumer,
                                                               token = self.request_token,
                                                               http_url = self.authorize_url)
    oauth_request.sign_request(self.signature_method, self.consumer, self.request_token)
    return oauth_request.to_url()
  
  def get_unauthorized_request_token(self):
    oauth_request = oauth.OAuthRequest.from_consumer_and_token(self.consumer, http_url = self.request_token_url)
    oauth_request.sign_request(self.signature_method, self.consumer, None)
    url = oauth_request.to_url()
    response = get(url)
    token = oauth.OAuthToken.from_string(response)
    return token

  # Exchange request token for access token
  def get_access_token_and_secret(self, pin):
    oauth_request = oauth.OAuthRequest.from_consumer_and_token(self.consumer,
                                                               http_url = self.access_token_url,
                                                               verifier = pin,
                                                               token = self.request_token)
    oauth_request.sign_request(self.signature_method, self.consumer, self.request_token)
    url = oauth_request.to_url()
    response = get(url)
    self.access_token = oauth.OAuthToken.from_string(response)
    access_token_data = dict((x, y) for x, y in urlparse.parse_qsl(response))                 # tuple to dict
    return access_token_data['oauth_token'], access_token_data['oauth_token_secret']
    
# TODO: Check also the possible inheritance with TwitterOauth
class API():
  def __init__(self, access_key, access_secret):
    self.signature_method = oauth.OAuthSignatureMethod_HMAC_SHA1()
    consumer_key, consumer_secret = read_consumer_key_and_secret()
    self.consumer = oauth.OAuthConsumer(consumer_key, consumer_secret)
    self.access_token = oauth.OAuthToken(access_key, access_secret)

class TwitterStreamAPI(API):
  def __init__(self, access_key, access_secret, callback):
    API.__init__(self, access_key, access_secret)

    self.user_stream_url = "https://userstream.twitter.com/2/user.json"
    self.callback = callback                                                                  # this method is going to be called as soon as a new entry on the stream appears
    thread = threading.Thread(target=self.tweet_streaming)
    thread.start()

  def tweet_streaming(self):
    oauth_request = oauth.OAuthRequest.from_consumer_and_token(self.consumer,
                                                               token = self.access_token,
                                                               http_url = self.user_stream_url)
    oauth_request.sign_request(self.signature_method, self.consumer, self.access_token)

    url = oauth_request.to_url()
    req = urllib2.urlopen(url)
    
    buffer = ''
    while True:
      chunk = req.read(1)
      if not chunk:
        print buffer
        break

      buffer += chunk
      tweets = buffer.split("\n",1)
      if len(tweets) > 1:
        content = tweets[0]
        if "text" in content:
          content = simplejson.loads(content)
          logp("Received from Twitter Stream: %s" % content)
          self.callback(content)                                                              # at the moment this method is called 'on_receive_new_tweet_callback'
        buffer = tweets[1]
 
class TwitterAPI(API):
  def __init__(self, access_key, access_secret):
    API.__init__(self, access_key, access_secret)
    
    self.update_url             = 'http://twitter.com/statuses/update.json'
    self.home_timeline_url      = 'http://twitter.com/statuses/home_timeline.json'
    self.direct_messages_url    = 'https://api.twitter.com/1/direct_messages.json'
    self.verify_credentials_url = 'https://api.twitter.com/1/account/verify_credentials.json'

  def tweet(self, message):                                                                   # popularly "send a tweet"
    oauth_request = oauth.OAuthRequest.from_consumer_and_token(self.consumer,
                                                               token = self.access_token,
                                                               http_url = self.update_url,
                                                               parameters = {'status':message},
                                                               http_method = "POST")
    oauth_request.sign_request(self.signature_method, self.consumer, self.access_token)
    post_data = oauth_request.to_postdata()
    return post(self.update_url, post_data)


  def home_timeline(self):
    oauth_request = oauth.OAuthRequest.from_consumer_and_token(self.consumer,
                                                               token = self.access_token,
                                                               http_url = self.home_timeline_url,
                                                               http_method = "GET")
    oauth_request.sign_request(self.signature_method, self.consumer, self.access_token)
    url = oauth_request.to_url()
    response = get(url) 
    return simplejson.loads(response)

  def direct_messages(self):
    oauth_request = oauth.OAuthRequest.from_consumer_and_token(self.consumer,
                                                               token = self.access_token,
                                                               http_url = self.direct_messages_url,
                                                               http_method = "GET")
    oauth_request.sign_request(self.signature_method, self.consumer, self.access_token)
    url = oauth_request.to_url()
    response = get(url)
    print simplejson.loads(response)[0]
    return simplejson.loads(response)

  def verify_credentials(self):
    oauth_request = oauth.OAuthRequest.from_consumer_and_token(self.consumer,
                                                               token = self.access_token,
                                                               http_url = self.verify_credentials_url,
                                                               http_method = "GET")
    oauth_request.sign_request(self.signature_method, self.consumer, self.access_token)
    url = oauth_request.to_url()
    response = get(url) 
    return simplejson.loads(response)

class User:
  def __init__(self, screen_name="", access_key="", access_secret=""):
    self.screen_name = screen_name
    self.access_key = access_key
    self.access_secret = access_secret

class Applet(CDApplet):

  def inform_start_of_waiting_process(self):
    self.icon.SetQuickInfo("...")

  def inform_end_of_waiting_process(self):
    self.icon.SetQuickInfo("")

  # Twitter methods

  # TODO: Make available a "Animation" option upon a new tweet arrival
  # This method is a callback that is called as soon as a new tweet that arrives on the stream
  # It is passed as parameter when creating the instance for the TwitterStreamAPI
  # TwitterStreamAPI(access_key, access_secret, self.on_receive_new_tweet_callback)
  def on_receive_new_tweet_callback(self, tweet):
    logp("Inserting new tweet on the stream Queue: %s" % tweet)
    self.stream.put(tweet)                                                                                              # put the new tweet on the stream queue
    self.icon.SetQuickInfo(str(self.stream.qsize()))                                                                    # update the new tweets counter on the icon

  def show_new_tweets(self):
    self.inform_start_of_waiting_process()
    message = ''
    while not self.stream.empty():                                                                                      # iterate on the stream composing the message
      tweet = self.stream.get()
      message += "[<b>%s</b>] %s\n" % (tweet['user']['name'], tweet['text'])
    dialog = {'use-markup':True}
    self.inform_end_of_waiting_process()
    self.show_popup_message(message, dialog)

  def show_home_timeline(self):
    self.inform_start_of_waiting_process()
    timeline = self.api.home_timeline()
    if len(timeline) > 0:
      message = "".join (["[<b>%s</b>] %s\n" % (status['user']['name'], status['text']) for status in timeline])
    else:
      message = _("Oh, dear, your timeline is empty :-(")
    dialog = {'use-markup':True}
    self.inform_end_of_waiting_process()
    self.show_popup_message(message, dialog)

  def show_direct_messages(self):
    self.inform_start_of_waiting_process()
    messages = self.api.direct_messages()
    if len(messages) > 0:
      message = "".join (["[<b>%s</b>] %s\n" % (status['sender']['name'], status['text']) for status in messages])
    else:
      message = _("Oh, dear, you do not have direct messages :-(")
    dialog = {'use-markup':True}
    self.inform_end_of_waiting_process()
    self.show_popup_message(message, dialog)

  def tweet(self, message):                                                                   # popularly "send a tweet"
    self.inform_start_of_waiting_process()
    self.api.update_status(message)
    self.inform_end_of_waiting_process()

  def show_credentials(self):
    self.inform_start_of_waiting_process()
    credentials = self.api.verify_credentials()
    message = _("%s [<b>%s</b>]\nFollowers: %s\nFriends: %s\nTweets: %s\n") % (credentials['name'], credentials['screen_name'], credentials['followers_count'], credentials['friends_count'], credentials['statuses_count'])
    dialog = {'use-markup':True}
    self.inform_end_of_waiting_process()
    self.show_popup_message(message, dialog)

  # Applet methods

  def ask_for_tweet(self):
    dialog = {'buttons':'ok;cancel'}
    widget = {'widget-type':'text-entry', 'nb-chars':140}                                     # 140 characters max, a tweet :)
    self.show_popup_message((_("%s, send a tweet")) % self.user.screen_name, dialog, widget)
    self.dialog_type = self.responding_tweet

  # TODO: Implement it as a config file using screen_name as section index
  def read_user_data(self):
    """Read the users file formated as Screen Name<space>Access Key<space>Access Secret"""
    found = False
    if os.path.exists(self.user_file):
      if os.path.getsize(self.user_file) > 0:
        f = open(self.user_file, "rb")
        data = f.read()
        self.user.screen_name, self.user.access_key, self.user.access_secret = data.split()   # split the line by space token
        f.close()
        found = True
    return found

  def write_user_data(self):
    f = open(self.user_file, 'w')
    f.write("%s %s %s" % (self.user.screen_name, self.user.access_key, self.user.access_secret))
    f.close()

  def show_initial_informations(self):
    message = _("Twitter Applet needs your nickname, and an authorization\nthat you accept it to connect on your Twitter account")
    dialog = {'buttons':'next'}
    self.show_popup_message(message, dialog)
    self.dialog_type = self.responding_initial_informations

  def ask_for_screen_name(self):
    message = _("What is your Twitter nickname?")
    dialog = {'buttons':'next'}
    widget = {'widget-type':'text-entry'}
    self.show_popup_message(message, dialog, widget)
    self.dialog_type = self.responding_screen_name

  def ask_for_authorization(self):
    authorization_url = self.twitter_auth.get_authorization_url()
    logp("Opening the auth URL '%s'" % authorization_url)
    dialog = {'buttons':'next'}
    try:
      webbrowser.open(authorization_url)
      message = _("Twitter applet needs you to give the authorization. Authorization page was opened on your browser. As soon as you authorize it, copy the PIN number that will be shown, and close this dialog")
      self.show_popup_message(message, dialog)
    except webbrowser.Error:    
      message = _("Twitter applet needs you to give the authorization. Copy the address bellow and access it with your browser. Copy the PIN number that will be shown as soon as you authorize")
      widget = {'widget-type':'text-entry', 'initial-value':authorization_url}
      self.show_popup_message(message, dialog, widget)
    self.dialog_type = self.responding_authorization

  def ask_for_pin_number(self):
    message = _("Enter the PIN number on the authorization page")
    dialog = {'buttons':'next'}
    widget = {'widget-type':'text-entry'}
    self.show_popup_message(message, dialog, widget)
    self.dialog_type = self.responding_pin

  def show_popup_successful_connection(self):
    self.show_popup_message(_("Successfully connected with Twitter"))

  def show_popup_message(self, message, dialog={}, widget={}):
    dialog_attributes = {'message':message}
    widget_attributes = {}
    dialog_attributes.update(dialog)
    widget_attributes.update(widget)
    self.icon.PopupDialog (dialog_attributes, widget_attributes)

  def build_direct_messages_menu(self):
    direct_messages_menu = []
    direct_messages_menu.append ({
        'type'  : CDApplet.MENU_ENTRY,
        'label' : _("Received direct messages"),
        'id'    : self.direct_messages_menu_id,
        'icon'  : os.path.abspath("./data/received.png")
    })
    self.icon.AddMenuItems(direct_messages_menu)

  def build_credentials_menu(self):
    credentials_menu = []
    credentials_menu.append ({
        'type'  : CDApplet.MENU_ENTRY,
        'label' : _("Info"),
        'id'    : self.credentials_menu_id,
        'icon'  : os.path.abspath("./data/credentials.png")
    })
    self.icon.AddMenuItems(credentials_menu)
    
  # TODO: As soon as clean up the API code, the label will be: "New tweets (%d)" % self.tweets_on_the_user_stream_queue
  def build_user_stream_menu(self):
    user_stream_menu = []
    user_stream_menu.append ({
        'type'  : CDApplet.MENU_ENTRY,
        'label' : _("New tweets"),
        'id'    : self.user_stream_menu_id,
        'icon'  : os.path.abspath("./data/new.png")
    })
    self.icon.AddMenuItems(user_stream_menu)

  def __init__(self):
    self.user = User()
    self.user_file = os.path.abspath(os.path.join(os.getcwd(), '..','..','..','.twitter_users'))  # ~/.config/.twitter_users
    self.twitter_auth = TwitterOauth()
    self.api = None
    self.stream_api = None
    (self.responding_screen_name, self.responding_authorization, self.responding_pin,
    self.responding_success, self.responding_tweet, self.responding_initial_informations) = range(6)
    self.dialog_type = None

    self.direct_messages_menu_id = 1000
    self.credentials_menu_id = 2000
    self.user_stream_menu_id = 3000
    
    self.stream = Queue.Queue()

    CDApplet.__init__(self)                                                                                                 # call CDApplet interface init

  # Inherited methods from CDApplet
  def begin(self):
    logp("Looking for user ...")
    if not self.read_user_data():                                                                                           # first time for the user
      logm("User not found")
      self.show_initial_informations()                                                                                      # start the wizard
    else:                                                                                                                   # user not found
      logp("User '%s' found" % self.user.screen_name)
      self.api = TwitterAPI(self.user.access_key, self.user.access_secret)                                                  # getting control over the api
      self.stream_api = TwitterStreamAPI(self.user.access_key, self.user.access_secret, self.on_receive_new_tweet_callback) # setting the callback to receive the data of every entry on the stream
  
  #def end(self):
    # TODO: Iterate over the array of threads and join them here
  
  # TODO: Fix it!
  def reload(self):
    self.read_user_data()

  # Callbacks
  def on_answer_dialog(self, key, content):
    if (key == 0 or key == -1):                                                       # ... and pressed Ok or Enter
      if self.dialog_type == self.responding_initial_informations:
        self.ask_for_screen_name()
      elif self.dialog_type == self.responding_screen_name:                           # user typed screen name ...
        logp("Receiving screen name '%s'" % content)
        self.user.screen_name = content
        self.ask_for_authorization()
      elif self.dialog_type == self.responding_authorization:
        logp("Asking for PIN")
        self.ask_for_pin_number()                                                     # ask for the PIN number received when acessed the auth URL
      elif self.dialog_type == self.responding_pin:                                   # user typed the PIN number
        logp("Receiving PIN: %s" % content)
        self.user.access_key, self.user.access_secret = self.twitter_auth.get_access_token_and_secret(content)
        logp("Writing user data")
        self.write_user_data()                                                        # writing the new users data
        self.api = TwitterAPI(self.user.access_key, self.user.access_secret)          # getting control over the api
        if self.api:
          self.show_popup_successful_connection()
        else:
          logm("A problem has occurred while getting access to the API")
      elif self.dialog_type == self.responding_tweet:
        logp("Sending a tweet '%s'" % content)
        self.api.tweet(content)

  def on_click(self, key):
    self.ask_for_tweet()

  def on_middle_click(self):
    self.show_home_timeline()

  def on_build_menu(self):
    self.build_direct_messages_menu()
    self.build_credentials_menu()
    if self.stream.qsize() > 0:
      self.build_user_stream_menu()

  def on_menu_select(self, selected_menu):
    if selected_menu == self.direct_messages_menu_id:
      self.show_direct_messages()
    elif selected_menu == self.credentials_menu_id:
      self.show_credentials()
    elif selected_menu == self.user_stream_menu_id:
      self.show_new_tweets()

if __name__ == '__main__':
  Applet().run()
